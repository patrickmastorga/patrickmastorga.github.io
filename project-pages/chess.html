<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chess Engine Project</title><script defer="defer" src="../713.bundle.js"></script><script defer="defer" src="../common.bundle.js"></script><script defer="defer" src="../project.bundle.js"></script></head><body><div class="container top"><div class="row"><div class="col-6" style="white-space:nowrap"><div class="logo"><a href="/index.html#navigation" class="logo-text">Patrick Astorga</a></div></div><div class="col-6 d-flex justify-content-end"><div class="home-icon"><a href="/index.html#navigation"><i class="pe-7s-home"></i></a></div></div></div></div><div class="container project"><h2 class="block_title">Chess Engine</h2><div class="row"><div class="col-12 col-lg-6"><div class="moreDetails"><h2 class="project-title">Chess Engine</h2><p>My favorite personal project, one that I am extremely passionate about, and still constantly make improvements to today. Since chess is a game that I actually play often, I find it fascinating when I can inject some of my own strategy and knowledge into my program, through chess specific heuristics and optimizations.</p><p>One of my favorite challenges was implementing all of rules of chess when programming the move generation framework. To work out all of the edge cases meant testing on dozens of positions.</p><p>This was my first time using a low level programming language like C++. I enjoyed having the freedom of programming styles and memory control. I recently began rewriting the entire codebase, and I decided to switch from Object Oriented to Procedural programming styles, as well as leveraging more low level optimizations such as bit-boards. The new version also runs in its own process, using inter-process communication and the UCI interface to transmit moves.</p><p>Implementing the traditional minimax algorithm was easy and I was happy to see that the engine was already quite tactical. Building its positional knowledge allowed me to inject my own heuristics into the evaluation function. I spent a while experimenting and implementing schemes such as PV-search: optimizing the alpha-beta pruning with move ordering and a transposition table lookup.</p><p>I created a front end application, also written in C++ with the SFML library so that my friends could play against my engine. I was extremely satisfied that none of my friends were able to beat it.</p><p>SIDE PROJECT: For a project in my Computing for Data Analysis class, I researched and implemented a miniature version of Stockfish's NNUE neural network evaluation function. It is a specialized network architecture with quantized activations and an efficiently updated extremely dense first layer for fast evaluation on a CPU. I had fun using low level special vectorized CPU instructions in my source code (1st gen) in order to implement the network from scratch (links: <a href="../documents/cx4240-final-project-presentation-95ada4487293fdc8ef8d.pdf" target="_blank" rel="noopener noreferrer" class="source">more info</a> | <a href="https://github.com/patrickmastorga/chess-data" target="_blank" rel="noopener noreferrer">training code</a>).</p><p>As I am now interested in a machine learning approach to chess, I incorporated new functionality for training deep neural networks into my rewritten code base. I wrote functions to parse the specialized binary training data format into a custom multi-threaded data loader which can be utilized by my python code.</p><p>Recently I trained a few deep neural networks (link: <a href="../documents/math4210-final-project-presentation-15feb8f96fe82714ad26.pdf" target="_blank" rel="noopener noreferrer" class="source">more info</a>), and my current mission is to incorporate them into my engine design. The challenge I am facing has to do with hardware. The engine runs sequentially on the CPU, but the neural network runs fastest in parallel on the GPU with batches of data. My goal is to implement a new search algorithm: Monte Carlo Tree Search. This is a probabilistic algorithm which can run many simulations in parallel.</p><p>Come back later and wee what I've accomplished!</p></div><div class="btn-center"><a href="https://github.com/patrickmastorga/chess-old" class="big button" target="_blank" rel="noopener noreferrer">Source Code (1st gen)</a></div><div class="btn-center"><a href="https://github.com/patrickmastorga/chess" class="big button" target="_blank" rel="noopener noreferrer">Source Code (2nd gen)</a></div></div><div class="col-12 col-lg-6 project-link"><img id="project-img" class="img-fluid d-block w-100 position-static mb-3" src="../images/chess-28df51a2f444baa54f60.webp" alt="chess"> <img id="project-img2" class="img-fluid d-block w-100 position-static mb-3" src="../images/chess-code-61ebf6437dce406e37de.webp" alt="chess"> <img id="project-img3" class="img-fluid d-block w-100 position-static" src="../images/chess-facts-99abdccc5b0e4602bffa.webp" alt="chess"></div></div></div></body></html>