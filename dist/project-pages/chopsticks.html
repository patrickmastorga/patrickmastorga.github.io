<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Chopsticks Project</title><script defer="defer" src="../common.bundle.js"></script><script defer="defer" src="../project.bundle.js"></script></head><body><div class="container top"><div class="row"><div class="col-6" style="white-space:nowrap"><div class="logo"><a href="/index.html#navigation" class="logo-text">Patrick Astorga</a></div></div><div class="col-6 d-flex justify-content-end"><div class="home-icon"><a href="/index.html#navigation"><i class="pe-7s-home"></i></a></div></div></div></div><div class="container project"><h2 class="block_title">Chopsticks</h2><div class="row"><div class="col-12 col-lg-6"><div class="moreDetails"><h2 class="project-title">Chopsticks Game</h2><p>One of my favorite games to play in elementary school, I decided that it would be a fun game to solve with programming. What made chopsticks different from connect four and checkers was that there is a relatively small number of positions. As a result, I saw two major shortcuts when programming an algorithm to play the best move.</p><p>The first and most obvious is that I can pre-compute everything and store it in a large table. Then at runtime, the program is very simple and efficient, also I can generate everything in python (way more fun).</p><p>I didn't realize the second shortcut until I had already programmed the first version of the python code. Like the connect four and checkers code, I was recursively branching over all possible moves from every individual starting position. As a result, I had to cap the depth of the search so my laptop wouldn't catch fire. I wasn't confident that my program was getting the absolute perfect results. After some head-scratching, I realized that since I was branching over a relatively small set, I could just start by computing the heuristic rating function (or whatever base case I wanted), and iterate over the table applying one step of the minimax search at a time. After some testing, I found that I was receiving the same results as the conventional recursive search. However, increasing the depth of the search could now be accomplished in linear time, and I was able to search as deep as I needed to be sure the program was finding every possible forced win.</p><p>Even though searching 100+ levels deep is extreme overkill for chopsticks, it was an interesting experiment to discover a way more efficient way of implementing the minimax algorithm. I can be 100% sure that my program is unbeatable on its hardest difficulty.</p></div><div class="row justify-content-center languages"><div class="col-2"><img id="python" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/python/python-original.svg" alt="python"></div><div class="col-2"><img id="javascript" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/javascript/javascript-original.svg" alt="javascript"></div><div class="col-2"><img id="html5" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/html5/html5-original.svg" alt="html5"></div><div class="col-2"><img id="css3" src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/css3/css3-original.svg" alt="css3"></div></div><div class="btn-center"><a href="https://github.com/patrickmastorga/chopsticks" class="big button" target="_blank" rel="noopener noreferrer">Source Code</a></div></div><div class="col-12 col-lg-6 project-link"><img id="project-img" src="../images/chopsticks-70b4c68ae5699977daf5.webp" alt="Chopsticks"> <a href="https://patrickmastorga.github.io/chopsticks/" target="_blank" rel="noopener noreferrer"><div id="project-overlay" class="overlay"><p>Click to play</p></div></a></div></div></div></body></html>